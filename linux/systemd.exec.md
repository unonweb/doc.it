**Execution environment configuration**; Unit configuration files for services, sockets, mount points, and swap devices share a subset of configuration options which define the execution environment of spawned processes.

* configuration options shared by: **services**, **sockets**, **mount points**, **swap**
* types: **service**; **sockets**; **mount**; **swap**
* sections: `[Service]`, `[Socket]`, `[Mount]`, `[Swap]`
## PIDFile

```ini
# myunit@.service
# systemctl start myunit@config1.service
[Service]
PIDFile=/var/run/myunit/%i.pid
# store a process ID file as /var/run/myunit/config1.pid
```


# ENVIRONMENT

- https://www.freedesktop.org/software/systemd/man/latest/systemd.exec.html#Environment

## EnvironmentFile

* [freedesktop.org](https://www.freedesktop.org/software/systemd/man/latest/systemd.exec.html#EnvironmentFile=)
* argument:
  should be an absolute filename or wildcard expression, optionally prefixed with "`-`", which indicates that if the file does not exist, it will not be read and no error or warning message is logged. This option may be specified more than once in which case all specified files are read.

# PATHS

```ini
[Service]
# Set the working directory for executed processes:
WorkingDirectory =
# a directory path relative to the service's root directory specified by RootDirectory=, 
WorkingDirectory = ~ 
# the home directory of the user specified in User= is used. If not set, defaults to the root directory when systemd is running as a system instance and the respective user's home directory if run as user. 

# If the setting is prefixed with the "-" character, a missing working directory is not considered fatal. If RootDirectory=/RootImage= is not set, then WorkingDirectory= is relative to the root of the system running the service manager. Note that setting this parameter might result in additional dependencies to be added to the unit (see above).   


RootDirectory =
# a directory path relative to the host's root directory (i.e. the root of the system running the service manager). Sets the root directory for executed processes, with the chroot(2) system call. If this is used, it must be ensured that the process binary and all its auxiliary files are available in the chroot() jail. Note that setting this parameter might result in additional dependencies to be added to the unit (see above).
# The MountAPIVFS= and PrivateUsers= settings are particularly useful in conjunction with RootDirectory=. For details, see below.
# If RootDirectory=/RootImage= are used together with NotifyAccess= the notification socket is automatically mounted from the host into the root environment, to ensure the notification interface can work correctly.
# Note that services using RootDirectory=/RootImage= will not be able to log via the syslog or journal protocols to the host logging infrastructure, unless the relevant sockets are mounted from the host, specifically:
```

# LOGGING & INPUT/OUTPUT

* [freedesktop.org](https://www.freedesktop.org/software/systemd/man/latest/systemd.exec.html#Logging%20and%20Standard%20Input/Output)
* `alert`, `crit`, `err`, `warning`, `notice`, `info`, `debug`

0  Emergency
1  Alert
2  Critical
3  Error
4  Warning
5  Notice
6  Informational
7  Debug

## LogExtraFields

```ini
LogExtraFields=FIELD=VALUE FIELD=VALUE
# Configures additional log metadata fields to include in all log records generated by processes associated with this unit.
# Takes one or more journal field assignments in the format "FIELD=VALUE" separated by whitespace.
```

## StandardInput / StandardOutput / StandardError

```sh
StandardInput=tty # standard input is connected to a TTY (as configured by `TTYPath=`) and the executed process becomes the controlling process of the terminal. If the terminal is already being controlled by another process, the executed process waits until the current controlling process releases the terminal.

StandardInput=tty-force # similar to `tty`, but the executed process is forcefully and immediately made the controlling process of the terminal, potentially removing previous controlling processes from the terminal.
```

If `StandardInput=` is set to one of `tty`, `tty-force`, `tty-fail`, `socket`, or `fd:name`, this setting defaults to `inherit`.

```sh
StandardOutput=inherit # duplicates the file descriptor of standard input for standard output

StandardOutput=file:/tmp/service.log
StandardOutput=file:path # may be used to connect a specific file system object to standard output. The semantics are similar to the same option of `StandardInput=`. If <path> refers to a regular file on the filesystem, it is opened (created if it doesn't exist yet using privileges of the user executing the systemd process) for writing at the beginning of the file, but without truncating it. If standard input and output are directed to the same file path, it is opened only once — for reading as well as writing — and duplicated. This is particularly useful when the specified path refers to an `AF_UNIX` socket in the file system, as in that case only a single stream connection is created for both input and output.

StandardOutput=tty # connects stdout to a tty (as configured via `TTYPath=`). If the TTY is used for output only, the executed process will not become the controlling process of the terminal, and will not fail or wait for other processes to release the terminal


StandardOutput=null
StandardOutput=tty
StandardOutput=journal
StandardOutput=kmsg
StandardOutput=journal+console
StandardOutput=kmsg+console
StandardOutput=append:path
StandardOutput=truncate:path
StandardOutput=socket
StandardOutput=fd:name
# Controls where file descriptor 1 (stdout) of the executed processes is connected to
```

## LogLevelMax

- [freedesktop.org](https://www.freedesktop.org/software/systemd/man/latest/systemd.exec.html#LogLevelMax=)
* **Drop log messages of a specific service above the specified level**
* `LogLevelMax=info` turns off debug logging of a particularly chatty unit
* The configured level is applied to any log messages written by any of the processes belonging to this unit, as well as any log messages written by the system manager process (PID 1) in reference to this unit

## LogFilterPatterns
- [freedesktop.org](https://www.freedesktop.org/software/systemd/man/latest/systemd.exec.html#LogFilterPatterns)
- **Filter log messages with a regex** 
  based on the `MESSAGE=` field of the structured message. 
- **only available in system services**
- If the first character of the pattern is "`~`", log entries matching the pattern should be discarded.
- "`~`" character is used to define denied patterns

## SyslogLevel

- [freedesktop.org](https://www.freedesktop.org/software/systemd/man/latest/systemd.exec.html#SyslogLevel=)
- The default **syslog** log level to use when logging to the logging system or the kernel log buffer. One of `emerg`, `alert`, `crit`, `err`, `warning`, `notice`, `info`, `debug`

```sh
SyslogLevel=emerg
SyslogLevel=alert
SyslogLevel=crit
SyslogLevel=err
SyslogLevel=warning
SyslogLevel=notice
SyslogLevel=info
SyslogLevel=debug
# The default syslog log level to use when logging to the logging system or the kernel log buffer.
# This option is only useful when StandardOutput= or StandardError= are set to journal or kmsg (or to the same settings in combination with +console), and only applies to log messages written to stdout or stderr. 
# Note that individual lines output by executed processes may be prefixed with a different log level which can be used to override the default log level specified here. The interpretation of these prefixes may be disabled with SyslogLevelPrefix=, see below. Defaults to "info".
```
## SyslogFacility

```sh
SyslogFacility=daemon
SyslogFacility=kern
SyslogFacility=user
SyslogFacility=mail
SyslogFacility=daemon
SyslogFacility=auth
SyslogFacility=syslog
SyslogFacility=lpr
SyslogFacility=news
SyslogFacility=uucp
SyslogFacility=cron
SyslogFacility=authpriv
SyslogFacility=ftp
SyslogFacility=local0, local1, local2, local3, local4, local5, local6, local7
# Sets the syslog facility identifier to use when logging. 
# This option is only useful when StandardOutput= or StandardError= are set to "journal" or "kmsg" (or to the same settings in combination with +console), and only applies to log messages written to stdout or stderr. Defaults to daemon.
```

## SyslogLevelPrefix

```sh
SyslogLevelPrefix=true
# If true and StandardOutput= or StandardError= are set to journal or kmsg (or to the same settings in combination with +console), log lines written by the executed process that are prefixed with a log level will be processed with this log level set but the prefix removed. 
# If false, the interpretation of these prefixes is disabled and the logged lines are passed on as-is. This only applies to log messages written to stdout or stderr.
# Defaults to true
```
## SyslogIdentifier

```bash
SyslogIdentifier=
# Sets the process name ("syslog tag") to prefix log lines sent to the logging system or the kernel log buffer with. If not set, defaults to the process name of the executed process. This option is only useful when StandardOutput= or StandardError= are set to journal or kmsg (or to the same settings in combination with +console) and only applies to log messages written to stdout or stderr
```

## TTYPath

Sets the terminal device node to use if standard input, output, or error are connected to a TTY (see above). Defaults to `/dev/console`.

# CREDENTIALS
## encryption

check if TPM 2.0 is available:

```bash
cat /sys/class/tpm/tpm0/tpm_version_major # 2 means available
```

encrypt secrets file with `systemd-creds`:

```bash
systemd-creds encrypt secrets/old/token_unencrypted secrets/token
```

load credentials in service unit:

```ini
[Unit]
Description=My Service
After=network-online.target

[Service]
ExecStart=/usr/bin/important-service
Type=exec
user=foo
WorkingDirectory=/home/foo

# Secrets
LoadCredentialEncrypted=token:/home/foo/secrets/token
```

## LoadCredentialEncrypted

Using encrypted and authenticated credentials improves security as credentials are not stored in plaintext and only authenticated and decrypted into plaintext the moment a service requiring them is started. Moreover, credentials may be bound to the local hardware and installations, so that they cannot easily be analyzed offline, or be generated externally.

Note that encrypted credentials targeted for services of the per-user service manager must be encrypted with `systemd-creds encrypt --user`, and those for the system service manager without the `--user` switch. Encrypted credentials are always targeted to a specific user or the system as a whole, and it is ensured that per-user service managers cannot decrypt secrets intended for the system or for other users.

## TPM

Services managed by systemd can now leverage a TPM for protecting credentials, bind them to your specific device and software configuration.

### check availability

```bash
sudo dmesg | grep TPM
systemd-creds has-tpm2
```
## LoadCredential

* [freedesktop.org](https://www.freedesktop.org/software/systemd/man/latest/systemd.exec.html#LoadCredential=ID:PATH)
* https://systemd.io/CREDENTIALS/
* https://medium.com/@umglurf/using-systemd-credentials-to-pass-secrets-from-hashicorp-vault-to-systemd-services-928f0e804518
* https://blog.sergeantbiggs.net/posts/credential-management-with-systemd/
* the user who runs the service no longer matters for its access to the secrets

The credential data is accessible from the unit's processes via the file system, at a read-only location that (if possible and permitted) is backed by non-swappable memory. 

**The data is only accessible to the user associated with the unit**, via the `User=`/`DynamicUser=` settings (as well as the superuser). 

When available, the location of credentials is exported as the `$CREDENTIALS_DIRECTORY` environment variable to the unit's processes.

It is a good idea to also enable mount namespacing for services that process credentials configured this way. If so, the runtime credential directory of the specific service is not visible to any other service. Use `PrivateMounts=` as minimal option to enable such namespacing. Note that many other sandboxing settings (e.g. `ProtectSystem=`, `ReadOnlyPaths=` and similar) imply `PrivateMounts=`, hence oftentimes it’s not necessary to set this option explicitly.

The credential files must be accessible to the service manager, but don't have to be directly accessible to the unit's processes: the credential data is read and copied into separate, read-only copies for the unit that are accessible to appropriately privileged processes. This is particularly useful in combination with `DynamicUser=` as this way privileged data can be made available to processes running under a dynamic UID without having to open up access to all users.
### argument

* **`LoadCredential=ID[:PATH]`**
* **Pass credentials from the service manager to the service**
* If the file system path is omitted it is chosen identical to the credential name
  The directories `/etc/credstore/`, `/run/credstore/` and `/usr/lib/credstore/` are searched for files under the credential's name — which hence are recommended locations for credential data on **disk**
### example

```sh
[Unit]
Description=Example service that depends on secrets

[Service]
Type=simple
DynamicUser=yes
LoadCredential=example-service.conf:/etc/example-service.conf
ExecStart=/usr/bin/example.sh --config-file=${CREDENTIALS_DIRECTORY}/example-service.conf
```

Now the user the service runs as no longer matters for its access to the secrets at all. The real config file can be readable for `root` only and it will still work fine.

### interface: unit & process

#### access creds via environment

1. When a service is invoked with one or more credentials set it will have an environment variable `$CREDENTIALS_DIRECTORY` set. It contains an absolute path to a directory the credentials are placed in. In this directory for each configured credential one file is placed. 
2. In addition to the `$CREDENTIALS_DIRECTORY` environment variable passed to the service processes the `%d` specifier in unit files resolves to the service’s credential directory.

```ini
[Service]
ExecStart=/usr/bin/myservice.sh
LoadCredential=foobar:/etc/myfoobarcredential.txt
Environment=FOOBARPATH=%d/foobar
```

Associated service shell script `/usr/bin/myservice.sh`:

```sh
#!/bin/sh
sha256sum $CREDENTIALS_DIRECTORY/foobar # method 1
sha256sum $FOOBARPATH # # method 2
```